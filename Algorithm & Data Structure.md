# Algorithm and Data Structure

- Binary Search:
  - Basic: [Template 3](https://aaronice.gitbooks.io/lintcode/content/knowledge/binary-search.html), Two termination conditions.
  - Complex problem to reduce time complexity:
    - [Median of two sorted arrays](https://www.lintcode.com/problem/median-of-two-sorted-arrays/description) - Binary Search on index
    - [Median of k sorted arrays](https://www.lintcode.com/problem/median-of-k-sorted-arrays/description) Binary Search on value
- Two Pointers: [Triangle Count](https://www.lintcode.com/problem/triangle-count/description) - Remember to fix largest edge.  
- Partition Array:
  - [Template](https://www.lintcode.com/problem/partition-array/description)
  - [Quick Select](https://www.lintcode.com/problem/kth-largest-element/description)
  - [Sort 3 colors](https://www.lintcode.com/problem/sort-colors/my-submissions)
  - [Sort k colors](https://www.lintcode.com/problem/sort-colors-ii/description)  
- BFS Traversal:
  - When to use BFS:
    - 图的遍历 Traversal in Graph
      - 层级遍历 Level Order Traversal
      - 由点及面 Connected Component
      - 拓扑排序 Topological Sorting
    - 最短路径 Shortest Path in Simple Graph
      - 仅限简单图求最短路径. 即图中每条边长度都是1，或者边长都相等. For more complex problems, use Dijkstra, Floyd.
  - BFS in Binary Tree: 
    - [Binary Tree Level Order Traversal](https://www.lintcode.com/problem/binary-tree-level-order-traversal/). The algorithm that requires levels need one more for loop.
    - [Binary Tree Serialization/Deserialization](https://www.lintcode.com/problem/serialize-and-deserialize-binary-tree/description)
  - BFS in Graph: (May have cycles, need to record visited nodes)
    - [Word Ladder](https://www.lintcode.com/problem/word-ladder/description)
  - BFS in Matrix: 
    - [Number of Islands](https://www.lintcode.com/problem/number-of-islands/description)  
      Create a direction array to help traversing all directions. Can also be solved by [Union Find](https://www.lintcode.com/problem/graph-valid-tree/description).
      ``` 
      int[] deltaX = new int[]{1,0,0,-1};
      int[] deltaY = new int[]{0,1,-1,0};
      ```
- [Topological Sort](https://www.lintcode.com/problem/topological-sorting/description)
  - [BFS solution(preferred, won't cause infinite loop)](https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/): Calculate **indegree** for each node, keep pushing nodes with indegree 0 to a queue. Poll nodes from queue and add to result.
  - [DFS solution(will cause infinite loop when there's a cycle)](https://www.geeksforgeeks.org/topological-sorting/): Create a **visited map and stack**. Recursively calling dfsHelper function to unvisited nodes. Push nodes to stack in the end of dfsHelper function so that all children are already in the stack when push the node to stack. Popping nodes from stack and add to result.
- DFS Traversal
  - DFS in Trees
    - Calculate values, max, min, avg...: [Lowest Common Ancestor](https://www.lintcode.com/problem/lowest-common-ancestor/description) - Use ResultType to pass values between recursions
    - Transformation: [Flatten Binary Tree to Linked List](https://www.lintcode.com/problem/flatten-binary-tree-to-linked-list/) - Use a global variable to track the last visited node.
    - Binary Search Tree(BST)
      - BST inorder traversal: [use stack](https://www.lintcode.com/problem/binary-search-tree-iterator/description), [use global variable "lastNode"](https://www.lintcode.com/problem/validate-binary-search-tree/my-submissions)
      - [Find the closest k elements to target in BST](https://www.lintcode.com/problem/closest-binary-search-tree-value-ii/description): BST inorder traversal + Binary Search
  - DFS for Combination and subsets: Use recursion
    - When to use: 1. When need to find **ALL** solutions. 2. Doesn't require order. 3. O(2^n)
    - Three key parts when using DFS: **Definition, Breakdown, Exit**
    - Classic problems:
      - [Subsets(distinct numbers)](https://www.lintcode.com/problem/subsets/description): nextIndex = index + 1
      - [Subsets II(with duplicates numbers)](https://www.lintcode.com/problem/subsets-ii/description): nextIndex = index + 1, Add additional check to avoid counting same number twice
      - [Combination Sum(one number can be used multiple times)](https://www.lintcode.com/problem/combination-sum/description): nextIndex = index
      - [Combination Sum II(one number can only be used once)](https://www.lintcode.com/problem/combination-sum-ii/description): nextIndex = index + 1
  - Permutation-based DFS
    - Basic permutations: [next permutation(find pivot point and swap)](https://www.lintcode.com/problem/next-permutation/description), [permutation index(no duplicates)](https://www.lintcode.com/problem/permutation-index/description)
    - Complex problems: [permutation index](https://www.lintcode.com/problem/permutation-index/description), [permutation index II(with duplicates)](https://www.lintcode.com/problem/permutation-index-ii/description)
  - Graph-based DFS: [N Queens](https://www.lintcode.com/problem/n-queens/description), [Phone letter combinations](https://www.lintcode.com/problem/letter-combinations-of-a-phone-number/description)
  - Memoization Search(Caching, same as DP):
    - [Wildcard Matching](https://www.lintcode.com/problem/wildcard-matching/description)
    - [Regular Expression Matching](https://www.lintcode.com/problem/regular-expression-matching/description)
    - [Word Break](https://www.lintcode.com/problem/word-break/description)
    - [Word Break II](https://www.lintcode.com/problem/word-break-ii/description)
    - [Word Pattern II](https://www.lintcode.com/problem/word-pattern-ii/description)
    - [Word Ladder II](https://www.lintcode.com/problem/word-ladder-ii/description)
  - DFS Complexity: https://www.jiuzhang.com/qa/2994/
- Data Strctures:
  - Linked List:
    - [LRU Cache](https://www.lintcode.com/problem/lru-cache/description)(Keep moving the latest element to tail. Can use either Singly or Double Linked List.** Easy to miss edge cases, careful**)
    - [First Unique Number in Data Stream](https://www.lintcode.com/problem/first-unique-number-in-data-stream/): Use map and linked list to track all unique numbers and update in the process.
  - Map: [Insert/Remove/GetRandom in O(1)](https://www.lintcode.com/problem/insert-delete-getrandom-o1/description)
  - Stack: Mainly used for DFS. [Min Stack](https://www.lintcode.com/problem/min-stack/description)
  - Queue: Mainly used for BFS. [Topological Sort](https://www.lintcode.com/problem/topological-sorting/description)
  - Heap: A tree data structure where parent is always bigger(maxHeap)/smaller(minHeap) than child nodes. It supports **O(logn) Add/Remove and O(1) Max/Min operations**.
    - Java PriorityQueue is **default to minHeap** with O(n) remove operation.
    - Example questions: [Ugly Number II](https://www.lintcode.com/problem/ugly-number-ii/description), [Sliding Window median](https://www.lintcode.com/problem/sliding-window-median/description)
    - Top K problem: [k closest points from origin](https://www.lintcode.com/problem/k-closest-points/description)(**customize comparator**), [top k largest numbers](https://www.lintcode.com/problem/top-k-largest-numbers-ii/description)(pay attention whether to use minHeap or maxHeap), [top k in big data](https://www.geeksforgeeks.org/how-to-find-top-n-records-using-mapreduce/)(using MapReduce)
    - Need to override **equals, compareTo, hashCode(parameter of type Object)** method of Comparable class when using PriorityQueue, Map, Set: [kth smallest number in sorted matrix](https://www.lintcode.com/problem/kth-smallest-number-in-sorted-matrix/description)
  - Matrix:
    - Use a 2D array to record sum of submatrix [(0, 0), (i-1, j-1)]
    - Example problem: [zero-sum submatrix](https://www.lintcode.com/problem/submatrix-sum/description)
  - Binary Indexed Tree(BIT):
    - Support calculating array preSum and update elements in Log(n) time
    - [Range Sum Query - Mutable](https://www.lintcode.com/problem/range-sum-query-mutable/description)(Remember the template)
- Union Find: A data structure that supports O(1) Union and O(1) find
  - Basic version(using array of index 0 - n-1): [Valid Tree](https://www.lintcode.com/problem/graph-valid-tree/description), [redundant connection](https://www.lintcode.com/problem/redundant-connection/description)
  - Advanced version:
    - [Number of islands II](https://www.lintcode.com/problem/number-of-islands-ii/description)(2D Union Find)
    - [Currency Exchange](https://leetcode.com/problems/evaluate-division/), [Merge Accounts](https://www.lintcode.com/problem/accounts-merge/description)(Using map and complex class)
  - Optimization: path compression and tree balancing(update subtree with fewer nodes)
- Trie: Used to build a dictionary for faster lookup exactly and prefix, use less space than hash
  - [Template](https://www.lintcode.com/problem/implement-trie-prefix-tree/description)(Trie class with a root TrieNode object)
  - [Search Regex(.)](https://www.lintcode.com/problem/add-and-search-word-data-structure-design/description)(Trie + DFS)
  - [Word Square](https://www.lintcode.com/problem/word-squares/description)(Build the map for each prefix + DFS)
  - [Word Search II](https://www.lintcode.com/problem/word-search-ii/description)
