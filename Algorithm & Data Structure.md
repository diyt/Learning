# Algorithm and Data Structure

- Binary Search:
  - Basic: has a range to do BS
    - [Template 3](https://aaronice.gitbooks.io/lintcode/content/knowledge/binary-search.html), Two termination conditions
    - [Median of two sorted arrays](https://www.lintcode.com/problem/median-of-two-sorted-arrays/description) - Binary Search on index
  - Complex: no explicit range to do BS. Guess result and test. Do BS on result range
    - [sqrt x](https://www.lintcode.com/problem/sqrtx/description)
    - [Wood Cut](https://www.lintcode.com/problem/wood-cut/description)
    - [Copy Books](https://www.lintcode.com/problem/copy-books/description)
    - [Median of k sorted arrays](https://www.lintcode.com/problem/median-of-k-sorted-arrays/description): guess kth number in 2D sorted array using BS
    - [Maximum Average SubArray II](https://www.lintcode.com/problem/maximum-average-subarray-ii/description)
- Two Pointers:
  - [Triangle Count](https://www.lintcode.com/problem/triangle-count/description) - Remember to fix largest edge.  
  - [Trapping Rain Water](https://www.lintcode.com/problem/trapping-rain-water/description)
- Partition Array:
  - [Template](https://www.lintcode.com/problem/partition-array/description)
  - [Quick Select](https://www.lintcode.com/problem/kth-largest-element/description)
  - [Sort 3 colors](https://www.lintcode.com/problem/sort-colors/my-submissions): Maintain three pointers: next position for i(0), j(1), k(2). While loop termination condition is j > k
  - [Sort k colors](https://www.lintcode.com/problem/sort-colors-ii/description)  
- BFS Traversal:
  - When to use BFS:
    - 图的遍历 Traversal in Graph
      - 层级遍历 Level Order Traversal
      - 由点及面 Connected Component
      - 拓扑排序 Topological Sorting
    - 最短路径 Shortest Path in Simple Graph
      - 仅限简单图求最短路径. 即图中每条边长度都是1，或者边长都相等. For more complex problems, use Dijkstra, Floyd.
  - BFS in Binary Tree: 
    - [Binary Tree Level Order Traversal](https://www.lintcode.com/problem/binary-tree-level-order-traversal/). The algorithm that requires levels need one more for loop.
    - [Binary Tree Serialization/Deserialization](https://www.lintcode.com/problem/serialize-and-deserialize-binary-tree/description)
  - BFS in Graph: (May have cycles, need to record visited nodes)
    - [Word Ladder](https://www.lintcode.com/problem/word-ladder/description)
  - BFS in Matrix: 
    - [Number of Islands](https://www.lintcode.com/problem/number-of-islands/description)  
      Create a direction array to help traversing all directions. Can also be solved by [Union Find](https://www.lintcode.com/problem/graph-valid-tree/description).
      ``` 
      int[] deltaX = new int[]{1,0,0,-1};
      int[] deltaY = new int[]{0,1,-1,0};
      ```
- [Topological Sort](https://www.lintcode.com/problem/topological-sorting/description)
  - [BFS solution(preferred, won't cause infinite loop)](https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/): Calculate **indegree** for each node, keep pushing nodes with indegree 0 to a queue. Poll nodes from queue and add to result.
  - [DFS solution(will cause infinite loop when there's a cycle)](https://www.geeksforgeeks.org/topological-sorting/): Create a **visited map and stack**. Recursively calling dfsHelper function to unvisited nodes. Push nodes to stack in the end of dfsHelper function so that all children are already in the stack when push the node to stack. Popping nodes from stack and add to result.
- DFS Traversal
  - DFS in Trees
    - Calculate values, max, min, avg...: [Lowest Common Ancestor](https://www.lintcode.com/problem/lowest-common-ancestor/description) - Use ResultType to pass values between recursions
    - Transformation: [Flatten Binary Tree to Linked List](https://www.lintcode.com/problem/flatten-binary-tree-to-linked-list/) - Use a global variable to track the last visited node.
    - Binary Search Tree(BST)
      - [Inorder](https://www.lintcode.com/problem/binary-tree-inorder-traversal/description)(Left, Root, Right), [Preorder](https://www.lintcode.com/problem/binary-tree-preorder-traversal/description)(Root, Left, Right), [PostOrder](https://www.lintcode.com/problem/binary-tree-postorder-traversal/description)(Left, Right, Root). Need to master recursive & non-recursive solution using stack.
      - BST inorder traversal: [use stack](https://www.lintcode.com/problem/binary-search-tree-iterator/description), [use global variable "lastNode"](https://www.lintcode.com/problem/validate-binary-search-tree/my-submissions)
      - [Find the closest k elements to target in BST](https://www.lintcode.com/problem/closest-binary-search-tree-value-ii/description): BST inorder traversal + Binary Search
  - DFS for Combination and subsets: Use recursion
    - When to use: 1. When need to find **ALL** solutions. 2. Doesn't require order. 3. O(2^n)
    - Three key parts when using DFS: **Definition, Breakdown, Exit**
    - Classic problems:
      - [Subsets(distinct numbers)](https://www.lintcode.com/problem/subsets/description): nextIndex = index + 1
      - [Subsets II(with duplicates numbers)](https://www.lintcode.com/problem/subsets-ii/description): nextIndex = index + 1, Add additional check to avoid counting same number twice
      - [Combination Sum(one number can be used multiple times)](https://www.lintcode.com/problem/combination-sum/description): nextIndex = index
      - [Combination Sum II(one number can only be used once)](https://www.lintcode.com/problem/combination-sum-ii/description): nextIndex = index + 1
  - Permutation-based DFS
    - Basic permutations: [next permutation(find pivot point and swap)](https://www.lintcode.com/problem/next-permutation/description)
    - Complex problems: [permutation index(no duplicates)](https://www.lintcode.com/problem/permutation-index/description), [permutation index II(with duplicates)](https://www.lintcode.com/problem/permutation-index-ii/description)
  - Graph-based DFS: [N Queens](https://www.lintcode.com/problem/n-queens/description), [Phone letter combinations](https://www.lintcode.com/problem/letter-combinations-of-a-phone-number/description)
  - Memoization Search:
    - [Wildcard Matching](https://www.lintcode.com/problem/wildcard-matching/description)
    - [Regular Expression Matching](https://www.lintcode.com/problem/regular-expression-matching/description)
    - [Word Break](https://www.lintcode.com/problem/word-break/description)
    - [Word Break II](https://www.lintcode.com/problem/word-break-ii/description)
    - [Word Pattern II](https://www.lintcode.com/problem/word-pattern-ii/description)
    - [Word Ladder II](https://www.lintcode.com/problem/word-ladder-ii/description)
  - DFS Complexity: https://www.jiuzhang.com/qa/2994/
- Data Strctures:
  - Linked List:
    - [LRU Cache](https://www.lintcode.com/problem/lru-cache/description)(Keep moving the latest element to tail. Can use either Singly or Double Linked List.** Easy to miss edge cases, careful**)
    - [First Unique Number in Data Stream](https://www.lintcode.com/problem/first-unique-number-in-data-stream/): Use map and linked list to track all unique numbers and update in the process.
  - Map: [Insert/Remove/GetRandom in O(1)](https://www.lintcode.com/problem/insert-delete-getrandom-o1/description)
  - Stack: Mainly used for DFS.
    - [Min Stack](https://www.lintcode.com/problem/min-stack/description)
    - [Decode String](https://www.lintcode.com/problem/decode-string/description)(**Pay attention to edge cases**)
    - Monotonous Stack: _Find the first smallest/biggest number on both sides in an array. O(n)_
      - [Largest Rectangle in Histogram](https://www.lintcode.com/problem/largest-rectangle-in-histogram/description): Remember to add 0 to the end to pop out all elements
      - [Maximal Rectangle](https://www.lintcode.com/problem/maximal-rectangle/description): Convert into 1D problem by using each row as baseline
      - [Max Tree](https://www.jianshu.com/p/53ebfd45559d): Maintain a decreasing stack. Whenever an element got popped out, it knows the first element bigger than it on both side, which are candidates to be it's parent node.
  - Queue: Mainly used for BFS. [Topological Sort](https://www.lintcode.com/problem/topological-sorting/description)
  - Dequeue: Implement by LinkedList, can support both stack and queue operations. [Sliding Window Maximum](https://www.lintcode.com/problem/sliding-window-maximum/description)(maintain monotonous dequeue for maximum candidates)
  - **Heap**: A tree data structure where parent is always bigger(maxHeap)/smaller(minHeap) than child nodes. It supports **O(logn) Add/Remove and O(1) Max/Min operations**.
    - Java PriorityQueue is **default to minHeap** with O(n) remove operation.
    - Example questions: [Ugly Number II](https://www.lintcode.com/problem/ugly-number-ii/description), [Sliding Window median](https://www.lintcode.com/problem/sliding-window-median/description), [2D Trapping Water](https://www.lintcode.com/problem/trapping-rain-water-ii/description)
    - Top K problem: [k closest points from origin](https://www.lintcode.com/problem/k-closest-points/description)(**customize comparator**), [top k largest numbers](https://www.lintcode.com/problem/top-k-largest-numbers-ii/description)(pay attention whether to use minHeap or maxHeap), [top k in big data](https://www.geeksforgeeks.org/how-to-find-top-n-records-using-mapreduce/)(using MapReduce)
    - Need to override **equals, compareTo, hashCode(parameter of type Object)** method of Comparable class when using PriorityQueue, Map, Set: [kth smallest number in sorted matrix](https://www.lintcode.com/problem/kth-smallest-number-in-sorted-matrix/description)
  - Matrix:
    - Use a 2D array to record sum of submatrix [(0, 0), (i-1, j-1)]
    - Example problem: [zero-sum submatrix](https://www.lintcode.com/problem/submatrix-sum/description)
  - Binary Indexed Tree(BIT):
    - Support calculating array preSum and update elements in Log(n) time
    - [Range Sum Query - Mutable](https://www.lintcode.com/problem/range-sum-query-mutable/description)(Remember the template)
- Union Find: A data structure that supports O(1) Union and O(1) find
  - Basic version(using array of index 0 - n-1): [Valid Tree](https://www.lintcode.com/problem/graph-valid-tree/description), [redundant connection](https://www.lintcode.com/problem/redundant-connection/description)
  - Advanced version:
    - [Number of islands II](https://www.lintcode.com/problem/number-of-islands-ii/description)(2D Union Find)
    - [Currency Exchange](https://leetcode.com/problems/evaluate-division/), [Merge Accounts](https://www.lintcode.com/problem/accounts-merge/description)(Using map and complex class)
  - Optimization: path compression and tree balancing(update subtree with fewer nodes)
- Trie: Used to build a dictionary for faster lookup exactly and prefix, use less space than hash
  - [Template](https://www.lintcode.com/problem/implement-trie-prefix-tree/description)(Trie class with a root TrieNode object)
  - [Search Regex(.)](https://www.lintcode.com/problem/add-and-search-word-data-structure-design/description)(Trie + DFS)
  - [Word Square](https://www.lintcode.com/problem/word-squares/description)(Build the map for each prefix + DFS)
  - [Word Search II](https://www.lintcode.com/problem/word-search-ii/description)
- Sweep Line: For interval problems, treat start/end edge separately and sort the edges.
  - [Num of airplanes](https://www.lintcode.com/problem/number-of-airplanes-in-the-sky/)
  - [Skyline problem](https://www.lintcode.com/problem/the-skyline-problem/description): comparater rules when sorting, use maxHeap to track the previous max rising height
- Dynamic Programming(DP)
  - Rolling Array(For array or matrix):
    - [Minimum Path Sum](https://www.lintcode.com/problem/minimum-path-sum/description)
    - [Max Square](https://www.lintcode.com/problem/maximal-square/)(square full of 1s)
    - [Max Square II](https://www.cnblogs.com/lz87/p/7393780.html)(square with only diagonal of 1s, maintain three dp arrays)
  - Memoization Search + DFS:
    - When to use: 1. Is one type of DP: hard to initialize. 2. State transition function not in sequence
    - Drawbacks: Takes more space, cannot optimize space. Depth of recursion can be deep
    - [Longest Increasing Continuous Subsequence II](https://algorithm.yuanbin.me/zh-hans/dynamic_programming/longest_increasing_continuous_subsequence_ii.html)
  - Gaming DP
    - [Coins in a line](https://www.lintcode.com/problem/coins-in-a-line/description): winner gets the last coin
    - [Coins in a line II](https://www.lintcode.com/problem/coins-in-a-line-ii/description): Winner gets the most sum
  - Interval DP: Bigger interval relies on smaller interval
    - [Burst Balloons](https://www.lintcode.com/problem/burst-balloons/description): Add 1s on both sides
  - Double Sequence DP: Usually 2D DP, use rolling array to optimize space
    - [Longest Common Sequence](https://www.lintcode.com/problem/longest-common-subsequence/description)
    - [Edit Distance](https://www.lintcode.com/problem/edit-distance/description)
    - [Interleaving String](https://www.lintcode.com/problem/interleaving-string/description)
  - Backpack DP: [Backpack series](https://segmentfault.com/a/1190000006325321)
    - This can usually be solved by two loops. First loop over all stones(what result can be formed using the first i stones), second loop over all capacity values. If don't allow duplicates, second loop is reverse, if allow duplicates, second loop is non-reverse. When defining dp array, make the size capacity + 1.
    - [Backpack I](https://www.lintcode.com/problem/backpack/description): dp[i] - if we can form weight i, [Minimum Partition](https://www.lintcode.com/problem/minimum-partition/description): **Remember to update from end to start to avoid duplicate counts**
    - [Backpack II](https://www.lintcode.com/problem/backpack-ii/description): dp[i][j] - The maximum value using the first i stones to form exactly weight j. If using 1D DP, remember to traverse from end to start to avoid duplicate counts
  - Iterator: Using stack to avoid recursion
    - [BST Iterator](https://www.lintcode.com/problem/binary-search-tree-iterator/description)
    - [Flatten Nestet List](https://www.lintcode.com/problem/flatten-list/)
    - [Flatten Nested List Iterator](https://www.lintcode.com/problem/flatten-nested-list-iterator/description)
